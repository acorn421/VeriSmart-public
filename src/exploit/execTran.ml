open Lang
open Vlang
open Query
open Semantics
open Transaction
open Options
open Vocab

let label_var_tid : int -> var -> var
= fun tid (x,t) -> (x ^ "@T" ^ string_of_int tid, t)

let tid_labeled : var -> bool
= fun (x,t) -> BatString.exists x "@T"

(* produce ghost variable for different tids *)
let label_var_entry_tid : int -> var -> var
= fun tid v -> v |> label_var_entry |> label_var_tid tid

let label_var_exit_tid : int -> var -> var
= fun tid v -> v |> label_var_exit |> label_var_tid tid

(* make read expression with integer index *)
let mk_read_int : var -> int -> vexp
= fun arr idx -> Read (VVar arr, VInt (BatBig_int.of_int idx), range_typ (snd arr))

let rec mk_elems_static' : var -> int -> vexp list
= fun arr idx ->
  let array_size = Vocab.remove_some (get_array_size (snd arr)) in
  if idx = array_size -1 then [mk_read_int arr idx]
  else mk_elems_static' arr (idx+1)

let mk_elems_static : var -> vexp list
= fun arr ->
  let _ = assert (is_static_array (snd arr)) in
  mk_elems_static' arr 0

let rec mk_elems_dynamic : var -> vexp list
= fun arr ->
  let _ = assert (is_dynamic_array (snd arr)) in
  [mk_read_int arr 0; mk_read_int arr 1]

let is_static_array_of_address : typ -> bool
= fun typ ->
  match typ with
  | Array (EType Address, Some _) -> true
  | _ -> false

let is_dynamic_array_of_address : typ -> bool
= fun typ ->
  match typ with
  | Array (EType Address, None) -> true
  | _ -> false

let collect_addr_vexps_from_vars : var list -> vexp list
= fun vars ->
  List.fold_left (fun acc (x,t) ->
    if is_address t then acc @ [VVar (x,t)]
    else if is_static_array_of_address t then acc @ (mk_elems_static (x,t))
    else if is_dynamic_array_of_address t then acc @ (mk_elems_dynamic (x,t))
    else acc
  ) [] vars

(***********************************************************************)
(***********************************************************************)
(*** Annotate non-global (i.e., local + keyword) variables with tids ***)
(***********************************************************************)
(***********************************************************************)

(* e.g., org ("x(#1)") = "x" *)
let org : var -> var
= fun (x,t) -> try (fst (BatString.split x "(#"), t) with Not_found -> (x,t)

let is_struct_member typ =
  match typ with
  | Mapping2 (Struct _,_) -> true
  | _ -> false

let rec label_vf : int -> var list -> var BatSet.t -> vformula -> vformula
= fun l gvars free vf ->
  match vf with
  | VTrue | VFalse -> vf
  | VNot f -> VNot (label_vf l gvars free f)
  | VAnd (f1,f2) -> VAnd (label_vf l gvars free f1, label_vf l gvars free f2)
  | VOr (f1,f2) -> VOr (label_vf l gvars free f1, label_vf l gvars free f2)
  | VBinRel (brel,e1,e2) -> VBinRel (brel, label_ve l gvars free e1, label_ve l gvars free e2)
  | Imply (f1,f2) -> Imply (label_vf l gvars free f1, label_vf l gvars free f2)
  | SigmaEqual _ | NoOverFlow _ -> assert false
  | ForAll (vars,f) -> ForAll (vars, label_vf l gvars free f)
  | Label (s,f) -> Label (s, label_vf l gvars free f)

and label_ve : int -> var list -> var BatSet.t -> vexp -> vexp
= fun l gvars free ve ->
  match ve with
  | VInt _ -> ve
  | VVar ("this",_) -> ve (* 'this' is fixed over the entire transactions, thus not labeled. *)
  | VVar (x,_) when BatString.ends_with x ".selector" -> ve
  | VVar v when List.mem (fst (org v)) global_ghost_var_names -> ve
  | VVar (x,typ) when is_struct_member typ -> ve (* do not add label to struct member variables *)
  | VVar (x,_) when BatString.starts_with x "@i" -> ve (* do not add label to quantified bound vars *)
  | VVar v ->
    (* add label for non-global variables that are not yet labeled *)
    if BatSet.mem v free && not (List.mem (org v) gvars) && not (tid_labeled v) then VVar (label_var_tid l v)
    else ve
  | Read (e1,e2,t) -> Read (label_ve l gvars free e1, label_ve l gvars free e2, t)
  | Write (e1,e2,e3) -> Write (label_ve l gvars free e1, label_ve l gvars free e2, label_ve l gvars free e3)
  | VBinOp (bop,e1,e2,t) -> VBinOp (bop, label_ve l gvars free e1, label_ve l gvars free e2, t)
  | VUnOp (uop,e,t) -> VUnOp (uop, label_ve l gvars free e, t)
  | VCast (t,e) -> VCast (t, label_ve l gvars free e)
  | VCond f -> VCond (label_vf l gvars free f)
  | Ite (e1,e2,e3) -> Ite (label_ve l gvars free e1, label_ve l gvars free e2, label_ve l gvars free e3)
  | Uninterp _ -> raise NotImplemented

(* necessary to distinguish local variables for each transactions *)
let label_tid : int -> var list -> vformula -> vformula
= fun tid gvars vf -> label_vf tid gvars (free_vf vf) vf

(******************************)
(******************************)
(*** Quantifier Elimination ***)
(******************************)
(******************************)

let rec addrs_vf : var -> int -> vformula -> vexp list
= fun x dim vf ->
  match vf with
  | VTrue | VFalse -> []
  | VNot f -> addrs_vf x dim f 
  | VAnd (f1,f2) -> (addrs_vf x dim f1) @ (addrs_vf x dim f2)
  | VOr (f1,f2) -> (addrs_vf x dim f1) @ (addrs_vf x dim f2)
  | VBinRel (_,e1,e2) -> (addrs_ve x dim e1) @ (addrs_ve x dim e2)
  | Imply (f1,f2) -> (addrs_vf x dim f1) @ (addrs_vf x dim f2)
  | SigmaEqual _ | NoOverFlow _ -> assert false
  | ForAll _ -> []
  | Label (_,f) -> addrs_vf x dim f

and addrs_ve : var -> int -> vexp -> vexp list
= fun x dim ve ->
  match ve with
  | VInt _ | VVar _ -> []
  | Read (VVar y, e2, _) (* y[e2] *)
    when dim=1 && BatString.equal (fst (org x)) (fst (org y)) ->
    [e2]
  | Read (Read (VVar y, e1, _), e2, _) (* y[e1][e2] *)
    when dim=2 && BatString.equal (fst (org x)) (fst (org y)) ->
    [e1;e2]
  | Read (e1,e2,_) -> (addrs_ve x dim e1) @ (addrs_ve x dim e2)
  | Write (VVar y, e2, e3) (* y[e2] := e3 *)
    when dim=1 && BatString.equal (fst (org x)) (fst (org y)) ->
    [e2] @ (addrs_ve x dim e3) 
  | Write (VVar y1, i, Write (Read (VVar y2, i', _), j, e))
    (* y[i][j] := e => y = write (y', i, write (y'[i],j,e))  *)
    when dim=2 && BatString.equal (fst (org x)) (fst (org y1)) && BatString.equal (fst (org y1)) (fst (org y2)) ->
    let _ = assert (equal_ve i i') in
    [i;j] @ (addrs_ve x dim e)
  | Write (e1,e2,e3) -> (addrs_ve x dim e1) @ (addrs_ve x dim e2) @ (addrs_ve x dim e3) 
  | VBinOp (_,e1,e2,_) -> (addrs_ve x dim e1) @ (addrs_ve x dim e2)
  | VUnOp (_,e,_) -> addrs_ve x dim e 
  | VCast (_,e) -> addrs_ve x dim e
  | VCond f -> addrs_vf x dim f
  | Ite (e1,e2,e3) -> (addrs_ve x dim e1) @ (addrs_ve x dim e2) @ (addrs_ve x dim e3)
  | Uninterp _ -> raise NotImplemented

let leave_entry_state_vars : var list -> vformula
= fun xs ->
  List.fold_left (fun acc x ->
    VAnd (acc, VBinRel (VEq, VVar (label_var_entry x), VVar x))
  ) VTrue xs

let leave_exit_state_vars : var list -> vformula
= fun xs ->
  List.fold_left (fun acc x ->
    VAnd (acc, Label (1, VBinRel (VEq, VVar (label_var_exit x), VVar x)))
  ) VTrue xs

let dynamic_array_length_two : var list -> vformula
= fun ivars ->
  let ivars = List.filter (fun (x,t) -> is_dynamic_array t) ivars in
  List.fold_left (fun acc var ->
    let arr_length = Read (VVar (length_map, Mapping2 (snd var, EType (UInt 256))), VVar var, EType (UInt 256)) in
    VAnd (acc, VBinRel (VEq, arr_length, VInt (BatBig_int.of_string "2")))
  ) VTrue ivars

let all_trusted : vexp list -> vformula
= fun addrs ->  
  List.fold_left (fun acc addr ->
    let const = VBinRel (VEq, Read (VVar trust_map, addr, EType Bool), VCond VTrue) in
    if equal_vf VTrue acc then const else VAnd (acc,const)
  ) VTrue addrs

let all_untrusted : vexp list -> vformula
= fun addrs ->
  List.fold_left (fun acc addr ->
    let const = VBinRel (VEq, Read (VVar trust_map, addr, EType Bool), VCond VFalse) in
    if equal_vf VTrue acc then const else VAnd (acc,const)
  ) VTrue addrs

let trusted_user_constraint : func -> var list -> BigIntSet.t -> vformula
= fun func ivars hc_addrs ->
  if is_constructor func then
    let hc_addrs = BigIntSet.to_list hc_addrs in
    let hc_addrs = List.map (fun n -> VInt n) hc_addrs in
    let addrs = collect_addr_vexps_from_vars ivars in
    let addrs = [VVar this_addr; VVar msg_sender; VInt BatBig_int.zero] @ hc_addrs @ addrs in (* this_addr itself is a trusted address. *)
    all_trusted addrs
  else
    let addrs = collect_addr_vexps_from_vars ivars in
    let addrs = (VVar msg_sender)::addrs in
    let t = all_trusted addrs in
    let u = all_untrusted addrs in
    VOr (t,u)

let init_invest_if_cnstr : func -> vformula
= fun func ->
  if is_constructor func then
    ForAll ([("@i", EType Address)], VBinRel (VEq, Read (VVar invest_map, VVar ("@i", EType Address), EType (UInt 256)), VInt BatBig_int.zero))
  else VTrue

let inc_invest_if_payable : func -> vformula -> vformula
= fun func vf ->
  if is_payable func then
    (* Invest[msg.sender] := Invest[msg.sender] + msg.value *)
    let target = VVar invest_map in
    let replacement = rename target in
    let vf' = rewrite_vf vf target replacement in
    let ve = Write (target, VVar msg_sender, VBinOp (VAdd, Read (target, VVar msg_sender, EType (UInt 256)), VVar msg_value, EType (UInt 256))) in
    let ve' = rewrite_ve ve target replacement in
    (* may be not necessary for disproving some queries, but maintain this to produce precise reports for debugging. *)
    VAnd (vf', Label (1, VBinRel (VEq,target,ve')))
  else vf

let investor_constraint : func -> vformula -> vformula
= fun func vf ->
  let vf = VAnd (vf, init_invest_if_cnstr func) in
  let vf = inc_invest_if_payable func vf in
  vf

let init_balance_if_cnstr : func -> vformula
= fun func ->
  if is_constructor func then
    VBinRel (VEq, Read (VVar eth_map, VVar this_addr, EType (UInt 256)), VInt !contract_init_eth)
  else VTrue

let inc_balance_if_payable : func -> vformula -> vformula
= fun func vf ->
  if is_payable func then
    (* B[this] := B[this] + msg.value *)
    let target = VVar eth_map in
    let replacement = rename target in
    let vf' = rewrite_vf vf target replacement in
    let this = VVar this_addr in
    let ve = Write (target, this, VBinOp (VAdd, Read (target,this,EType (UInt 256)), VVar msg_value, EType (UInt 256))) in
    let ve' = rewrite_ve ve target replacement in
    (* may be not necessary for disproving some queries, but maintain this to produce precise reports for debugging. *)
    VAnd (vf', Label (1, VBinRel (VEq,target,ve')))
  else vf

let balance_constraint : func -> vformula -> vformula
= fun func vf ->
  let vf = VAnd (vf, init_balance_if_cnstr func) in
  let vf = inc_balance_if_payable func vf in
  vf

let valid_sender () =
  Label (1, VNot (VBinRel (VEq, VVar msg_sender, VInt BatBig_int.zero)))

let sender_this_different () =
  Label (1, VNot (VBinRel (VEq, VVar msg_sender, VVar this_addr)))

let cnstr_args_cannot_be_this : func -> var list -> vformula
= fun func ivars ->
  if is_constructor func then
    let addrs = collect_addr_vexps_from_vars ivars in
    List.fold_left (fun acc addr ->
      VAnd (acc, VNot (VBinRel (VEq, VVar this_addr, addr)))
    ) VTrue addrs
  else VTrue

(* For likely scenarios, enforce address types arguments not to be zero addresses. *)
let likely_addr_args : func -> var list -> vformula
= fun func ivars ->
  let addrs = collect_addr_vexps_from_vars ivars in
  List.fold_left (fun acc addr ->
    let valid_addr = Label (1, VNot (VBinRel (VEq, addr, VInt BatBig_int.zero))) in
    VAnd (acc, valid_addr)
  ) VTrue addrs

(* for automatic concrete validation *)
let sender_not_hard_code_addrs : BigIntSet.t -> vformula
= fun hc_addrs ->
  BigIntSet.fold (fun addr acc ->
    VAnd (acc, Label (1, VNot (VBinRel (VEq, VVar msg_sender, VInt addr))))
  ) hc_addrs VTrue

let calldata_length : func -> vformula
= fun func ->
  let typs = List.map (fun (_,info) -> info.vtype) (get_params func) in
  let b = List.for_all (fun t -> is_uintkind t || is_sintkind t || is_address t || is_bool t) typs in
  if b then
    let size = 4 + ((List.length typs) * 32) in (* 4 bytes for function signature + #arg * 32  *)
    VBinRel (VEq, VVar ("msg.data.length", EType (UInt 256)), VInt (BatBig_int.of_int size))
  else VTrue

(* to generate reasonable vulnerable transactions *)
let restrict_ether : func -> vformula
= fun func ->
  if not (is_payable func) || !Options.infinite_ether then VTrue
  else
    let ten_ether = BatBig_int.of_string "10000000000000000000" in (* 10 ether = (10**18) * 10 *)
    let limit = Label (1, VBinRel (VGeq, VInt ten_ether, VVar msg_value)) in
    limit

let zero_value_if_non_payable : func -> vformula
= fun func ->
  if not (is_payable func) then Label (1, VBinRel (VEq, VVar msg_value, VInt BatBig_int.zero))
  else VTrue

let add_aux_constraint : Global.t -> BigIntSet.t -> func -> var list -> vformula -> vformula
= fun global hc_addrs func ivars vf ->
  let vf = VAnd (vf, valid_sender ()) in
  let vf = VAnd (vf, sender_this_different ()) in
  let vf = VAnd (vf, sender_not_hard_code_addrs hc_addrs) in
  let vf = VAnd (vf, cnstr_args_cannot_be_this func ivars) in
  let vf = VAnd (vf, likely_addr_args func ivars) in
  let vf = VAnd (vf, leave_entry_state_vars ((eth_map) :: ivars @ global.gvars)) in
  let vf = VAnd (vf, dynamic_array_length_two ivars) in
  let vf = VAnd (vf, calldata_length func) in
  let vf = VAnd (vf, zero_value_if_non_payable func) in
  let vf = VAnd (vf, restrict_ether func) in
  let vf = VAnd (vf, trusted_user_constraint func ivars hc_addrs) in
  let vf = balance_constraint func vf in
  let vf = investor_constraint func vf in
  vf

(* addresses defined in cnstrs are trusted accounts. *)
let addrs_defined_in_cnstr_trusted : func -> Node.t list -> vformula
= fun func bp ->
  if is_constructor func then
    let g = get_cfg func in
    List.fold_left (fun acc node ->
      let stmt = find_stmt node g in
      match stmt with
      | Assign (lv,_,_) when is_address (get_type_lv lv) ->
        let const = VBinRel (VEq, Read (VVar trust_map, convert_lv lv, EType Bool), VCond VTrue) in
        VAnd (acc,const)
      | Call (Some lv,_,_,_,_,_,_) when is_address (get_type_lv lv) ->
        let const = VBinRel (VEq, Read (VVar trust_map, convert_lv lv, EType Bool), VCond VTrue) in
        VAnd (acc,const)
      | _ -> acc
    ) VTrue bp
  else VTrue

let exec_transaction : Global.t -> BigIntSet.t -> transaction -> vformula * query list ->
                       vformula * query list
= fun global hc_addrs (tid,path) (vf,qs) ->
  let func = FuncMap.find (Path.get_fkey path) global.fmap in
  let g = Lang.get_cfg func in
  let bp = Path.get_bp path in
  let ivars = List.map (fun (v,vinfo) -> (v,vinfo.vtype)) (Lang.get_params func) in
  let vf = add_aux_constraint global hc_addrs func ivars vf in
  let (vf',qs') =
    List.fold_left (fun (acc_vf,acc_qs) node ->
      let new_qs = CollectQuery.collect global g acc_vf path node in
      convert_stmt global func node (acc_vf, acc_qs @ new_qs)
    ) (vf, qs) bp
  in
  let vf' = VAnd (vf', addrs_defined_in_cnstr_trusted func bp) in
  let vf' = VAnd (vf', leave_exit_state_vars [eth_map]) in
  (label_tid tid global.gvars vf',
   List.map (fun q -> {q with vc = label_tid tid global.gvars q.vc;
                              vc2 = label_tid tid global.gvars q.vc2}) qs')


let exec_transactions : Global.t -> BigIntSet.t -> transaction list -> vformula * query list
= fun global hc_addrs tseq ->
  let last_index = List.length tseq - 1 in
  let valid_this_addr = VNot (VBinRel (VEq, VVar this_addr, VInt BatBig_int.zero)) in
  let (formula, queries) =
    BatList.fold_lefti (fun (vf,qs) i t ->
      let (vf', qs') = exec_transaction global hc_addrs t (vf,qs) in
      let qs'' = if i = last_index then qs' else [] in
      (vf', qs'')
    ) (valid_this_addr,[]) tseq in
  let queries' = List.map (fun q -> {q with vc2 = Imply (formula, q.vc2)}) queries in
  (formula, queries')
