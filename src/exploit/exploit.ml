open Lang
open Vlang
open Z3Interface
open Vocab
open Options
open Query
open Prob
open Feature
open Path
open Semantics
open Yojson.Basic
open ReportExploit
open Transaction
open ExecTran

let rec qe_f : vformula -> vformula -> vformula
= fun whole vf ->
  match vf with
  | VTrue | VFalse -> vf
  | VNot f -> VNot (qe_f whole f) 
  | VAnd (f1,f2) -> VAnd (qe_f whole f1, qe_f whole f2)
  | VOr (f1,f2) -> VOr (qe_f whole f1, qe_f whole f2)
  | VBinRel (brel,e1,e2) -> vf
  | Imply (f1,f2) -> Imply (qe_f whole f1, qe_f whole f2)
  | SigmaEqual _ | NoOverFlow _ -> assert false
  | ForAll ([i],VBinRel (VEq, Read (VVar x, VVar i',t), e)) when is_mapping (snd x) ->
    let _ = assert (i=i') in
    let addrs = addrs_vf x 1 whole in
    let addrs = List.sort_uniq compare_ve addrs in 
    List.fold_left (fun acc p ->
      let f = VBinRel (VEq, Read (VVar x, p, t), e) in
      if equal_vf acc VTrue then f 
      else VAnd (acc, f) 
    ) VTrue addrs
  | ForAll ([i;j],VBinRel (VEq, Read (Read (VVar x,VVar i',t1), VVar j', t2), e)) when is_mapping (snd x) ->
    let _ = assert (i=i' && j=j') in
    let addrs = addrs_vf x 2 whole in
    let rec get_pairs lst =
      (match lst with
       | [] -> []
       | (h1::h2::tl) -> [(h1,h2)] @ (get_pairs tl)
       | _ -> failwith "qe_f : get_pairs") in
    let addr_pairs = get_pairs addrs in
    let compare_pair (a,a') (b,b') =
      let res = compare_ve a b in
      if res = 0 then compare_ve a' b' else res in
    let addr_pairs = List.sort_uniq compare_pair addr_pairs in 
    List.fold_left (fun acc (p,q) ->
      let f = VBinRel (VEq, Read (Read (VVar x, p, t1), q, t2), e) in
      if equal_vf acc VTrue then f
      else VAnd (acc, f) 
    ) VTrue addr_pairs
  | ForAll (_,VTrue) ->
    (* this case may appear when constraints are invalidated by
     * assembly block or function calls that are not inlined. *)
    vf
  | ForAll _ -> vf
    (* failwith ("qe_f (ForAll) : " ^ to_string_vformula vf) *)
  | Label (l,f) -> Label (l, qe_f whole f)

let quantifier_elimination vf = qe_f vf vf


let rec mk_ngram : int -> 'a list -> 'a list list
= fun n lst ->
  let ngram = BatList.take n lst in
  if List.length lst = n then [ngram]
  else ngram :: (mk_ngram n (List.tl lst))

let compute_score : Global.t -> TypeRank.t -> string BatSet.t ->
                    NGramMap.t -> NGramMap.t -> NGramMap.t -> NGramMap.t ->
                    transaction list -> float
= fun global rank dict uni_count bi_count tri_count quad_count tseq ->
  if !Options.ngram <= 0 then float_of_int (List.length tseq)
  else
    let rec add_pseudo_words n = if n=0 then [] else (S::add_pseudo_words (n-1)) in
    let word_list = mk_word_list global rank dict tseq in
    let sentence = (add_pseudo_words (!Options.ngram-1)) @ word_list in
    let ngrams = mk_ngram !Options.ngram sentence in
    let log_prob =
      List.fold_left (fun acc ngram ->
        let str = Feature.to_string_sentence ngram in
        let prob =
          if !Options.ngram = 2 then Prob.interpolation_bi dict uni_count bi_count tri_count quad_count str else
          if !Options.ngram = 3 then Prob.interpolation_tri dict uni_count bi_count tri_count quad_count str else
          if !Options.ngram = 4 then Prob.interpolation_quad dict uni_count bi_count tri_count quad_count str
          else failwith "unknown ngram option" in
        acc +. prob
      ) (log 1.) ngrams in
    if BatString.equal !Options.debug "prob" then
     (prerr_endline "\n";
      prerr_endline (to_string_tseq global tseq);
      prerr_endline (to_string_sentence sentence);
      prerr_endline (string_of_float log_prob);
      prerr_endline (string_of_float (exp log_prob)));
    -. log_prob


module Workset = struct
  type elem = float * bool * transaction list

  module OrderedType = struct
    type t = elem
    let compare (cost1,_,_) (cost2,_,_) = Stdlib.compare cost1 cost2
  end

  module Heap = BatHeap.Make (OrderedType)

  type t = Heap.t

  let empty = Heap.empty

  let pick_min : t -> elem option
  = fun heap -> 
    try Some (Heap.find_min heap)
    with _ -> None

  let remove_min : t -> t
  = fun heap ->  Heap.del_min heap

  let add : t -> elem -> t
  = fun heap work -> Heap.add work heap

  let workset_info : t -> string
  = fun heap -> "# of Workset Elements : " ^ string_of_int (Heap.size heap)
end

let sat_wrapper: vformula -> int * Z3.Model.model option
= fun f -> Z3Interface.is_sat f

(* outputs next candidates *)
let next : vformula -> Global.t -> PathSet.t -> transaction list -> transaction list list
= fun state global paths tseq ->
  let safety = VFalse in
  let pgm_const = state in
  let vc = VAnd (state, VNot safety) in
  let dep_vars = Opt.compute_dependant_vars pgm_const safety in
  let vc_opt = Opt.remove_unrelated_part dep_vars vc in
  let _ = assert (not (has_label vc_opt)) in
  let vc_qe = quantifier_elimination vc_opt in
  let vc_pow = Simplification.remove_pow vc_qe in
  let vc_sim = Simplification.fix Simplification.normalize vc_pow in
  let (signal,mop) = sat_wrapper vc_sim in
  if signal = 0 then [] (* UNSAT: infeasible path *)
  else
  (* let state = Simplification.fix_normalize state in
  if equal_vf state VFalse then []
  else *)
    PathSet.fold (fun new_p acc ->
      let last_tx = BatList.last tseq in
      let last_tx_fname = get_fname (FuncMap.find (Path.get_fkey (get_path last_tx)) global.fmap) in
      if not (BatString.starts_with last_tx_fname "smartest_")
         && List.length tseq - 1 < !Options.transaction_depth (* substract 1 to exclude constructor when counting length *) then
         let new_t = (fresh_tid (), new_p) in
         (tseq @ [new_t])::acc
      else acc
    ) paths []

let flag = ref false

let violation_found : query -> QMap.t -> bool
= fun q qmap ->
  let (status,_,_,_,_,_,_,_,_) = QMap.find (QMap.mk_key q) qmap in
  status = Disproven

let debug global tseq dep_vars vc vc_opt vc_qe vc_pow vc_sim =
  if BatString.equal !Options.debug "formula" then
    (prerr_endline "=== sequence ===";
     print_endline (to_string_transactions_simple global tseq);
     prerr_endline "=== dependant variables ===";
     prerr_endline (string_of_set (fst |> id) dep_vars);
     prerr_endline "=== initial ===";
     prerr_endline (to_string_vformula vc);
     prerr_endline "=== after sparsified ===";
     prerr_endline (to_string_vformula vc_opt);
     prerr_endline "=== after quantifier elimination ===";
     prerr_endline (to_string_vformula vc_qe);
     prerr_endline "=== after removing power ===";
     prerr_endline (to_string_vformula vc_pow);
     prerr_endline "=== after simplified ===";
     prerr_endline (to_string_vformula vc_sim);
     prerr_endline "")

let exist_inter_contract_call : Global.t -> transaction list -> bool
= fun global tseq ->
  List.exists (fun (tid,path) ->
    let func = FuncMap.find (Path.get_fkey path) global.fmap in
    let g = Lang.get_cfg func in
    let nodes = Path.get_bp path in
    List.exists (fun node ->
      let stmt = find_stmt node g in
      match stmt with
      | Call (lvop,e,args,_,_,loc,_) ->
        not (FuncMap.is_undef e (List.map get_type_exp args) global.fmap) &&
        not (is_static_call global.cnames stmt)
      | _ -> false
    ) nodes
  ) tseq

let choose_final_vc : query -> vformula
= fun q ->
  if !Options.refined_vcgen then
    match q.kind with
    | IO -> q.vc2
    | DZ -> q.vc
    | ASSERT -> q.vc
    | KILL -> q.vc
    | ETH_LEAK ->
      (match q.org_q with
       | Org_Stmt (Call (lvop,Lv (Var (fname,_)),args,_,_,loc,_))
         when List.mem fname ["selfdestruct";"suicide"] -> q.vc
       | Org_Stmt (Call (lvop,Lv (MemberAccess (e,fname,_,_)),args,_,_,loc,_))
         when is_address (get_type_exp e) && List.mem fname ["transfer";"send"] -> q.vc2
       | Org_Stmt (Call (lvop, Lv (MemberAccess (e,"call",_,_)), args, Some eth, gasop, loc, id))
         when is_address (get_type_exp e) -> q.vc2
       | _ -> assert false)
    | ERC20 -> q.vc
  else q.vc

let rec work : Global.t -> BigIntSet.t -> TypeRank.t -> string BatSet.t ->
               NGramMap.t -> NGramMap.t -> NGramMap.t -> NGramMap.t ->
               PathSet.t -> int list BatSet.t -> Workset.t -> QMap.t -> QMap.t
= fun global hc_addrs rank dict uni_count bi_count tri_count quad_count paths explored workset qmap ->
  iter := !iter + 1;
  if !iter mod 1000 = 1 then
    (prerr_string ("Iter : " ^ string_of_int !iter ^ ", ");
     prerr_endline (Workset.workset_info workset ^ ", " ^ "Total elapsed : " ^ (string_of_float (Sys.time () -. !Profiler.start_cpu))));
  if QMap.for_all (fun k (stat,_,_,_,_,_,_,_,_) -> stat = Disproven) qmap then qmap else
  if (Sys.time () -. !Profiler.start_cpu) > float_of_int !Options.exploit_timeout then qmap
  else
  match Workset.pick_min workset with
  | None -> qmap
  | Some (prob,b,tseq) ->
    max_explored_depth := max !max_explored_depth (List.length tseq - 1);
    if BatString.equal !Options.debug "wpick" then
    prerr_endline (to_string_tseq global tseq ^ "," ^ "log prob: " ^ string_of_float (-. prob) ^ "," ^ "prob: " ^ string_of_float (exp (-. prob)));
    let workset = Workset.remove_min workset in
    let (state,queries) = exec_transactions global hc_addrs tseq in
    let qmap =
      List.fold_left (fun acc q ->
        if (Sys.time () -. !Profiler.start_cpu) > float_of_int !Options.exploit_timeout then acc else
        if violation_found q acc then acc
        else
          let vc = choose_final_vc q in
          let (pgm_const,safety) = split_implication vc in
          let vc = VAnd (pgm_const, VNot safety) in
          let dep_vars = Opt.compute_dependant_vars pgm_const safety in
          let vc_opt = Opt.remove_unrelated_part dep_vars vc in
          let _ = assert (not (has_label vc_opt)) in
          let vc_qe = quantifier_elimination vc_opt in
          let vc_pow = Simplification.remove_pow vc_qe in
          let vc_sim = Simplification.fix Simplification.normalize vc_pow in
          let _ = debug global tseq dep_vars vc vc_opt vc_qe vc_pow vc_sim in
          let (signal,mop) = sat_wrapper vc_sim in
          let _ = formula_cnt := !formula_cnt + 1 in
          let _ = if signal=2 then timeout_cnt := !timeout_cnt + 1 in
            if signal=1 then
              (if BatString.equal !Options.debug "success" then
                 prerr_endline (to_string_tseq global tseq ^ " : " ^ string_of_float prob ^ "," ^ string_of_float (exp (-. prob)));
               flag:=true;
               last_disproven_iter := !iter;
               last_disproven_time := Sys.time () -. !Profiler.start_cpu;
               max_disproven_depth := max !max_disproven_depth (List.length tseq - 1);
               (* print_endline (to_string_vformula vc);
               print_endline (to_string_vformula vc_sim);
               print_endline (Z3.Model.to_string (remove_some mop));
               print_endline (Path.to_string q.path); *)
               QMap.add (QMap.mk_key q) (Disproven, tseq, mop, vc, q.sc_src, q.attacker_src, q.eth_src, Sys.time() -. !Profiler.start_cpu, false) acc)
            else acc
      ) qmap queries in
    let nexts = next state global paths tseq in
    let dup_exist = List.exists (fun next_tseq -> (BatSet.mem (List.map fst next_tseq) explored)) nexts in
    let _ = assert (not dup_exist) in (* invariant: duplicated sequences are not enumerated *)
    let explored = List.fold_left (fun acc next_tseq -> BatSet.add (List.map fst next_tseq) acc) explored nexts in
    let nexts = List.map (fun next -> (compute_score global rank dict uni_count bi_count tri_count quad_count next, exist_inter_contract_call global next, next)) nexts in
    let workset = List.fold_left Workset.add workset nexts in
    work global hc_addrs rank dict uni_count bi_count tri_count quad_count paths explored workset qmap

let rec hc_lv : lv -> BigIntSet.t
= fun lv ->
  match lv with
  | Var _ -> BigIntSet.empty
  | MemberAccess (e,_,_,_) -> hc_exp e
  | IndexAccess (e,None,_) -> hc_exp e
  | IndexAccess (e1,Some e2,_) -> BigIntSet.union (hc_exp e1) (hc_exp e2)
  | Tuple (eops,_) ->
    List.fold_left (fun acc eop ->
      match eop with
      | None -> acc
      | Some e -> BigIntSet.union (hc_exp e) acc
    ) BigIntSet.empty eops

and hc_exp : exp -> BigIntSet.t
= fun exp ->
  match exp with
  | Int n -> BigIntSet.empty
  | Real _ | Str _ -> BigIntSet.empty
  | Lv lv -> hc_lv lv
  | Cast (EType Address, Int n) when not (BatBig_int.equal n BatBig_int.zero) -> BigIntSet.singleton n
  | Cast (_,e) -> hc_exp e
  | BinOp (_,e1,e2,_) -> BigIntSet.union (hc_exp e1) (hc_exp e2)
  | UnOp (_,e,_) -> hc_exp e
  | True | False -> BigIntSet.empty
  | ETypeName _ -> BigIntSet.empty
  | _ -> failwith "hc_exp: temp expressions encountered"

let collect_hc_addrs_node : cfg -> Node.t -> BigIntSet.t -> BigIntSet.t
= fun g node collected_hcs ->
  let stmt = find_stmt node g in
  let is_address_array typ = match typ with Array (EType Address,_) -> true | _ -> false in
  match stmt with
  | Assign (lv,Int n,_) when is_address (get_type_lv lv) && not (BatBig_int.equal n BatBig_int.zero) ->
    BigIntSet.add n collected_hcs
  | Assign (lv,Lv (Tuple (eops,_)),_) when is_address_array (get_type_lv lv) ->
    List.fold_left (fun acc eop ->
      match eop with
      | Some (Int n) -> BigIntSet.add n acc
      | Some _ -> acc
      | None -> acc
    ) collected_hcs eops
  | Assign (lv,e,_) -> BigIntSet.union (hc_exp e) collected_hcs
  | Assume (e,_) -> BigIntSet.union (hc_exp e) collected_hcs
  | Assert (e,_,_) -> BigIntSet.union (hc_exp e) collected_hcs
  | Call (lvop,_,args,_,_,loc,_) ->
    let hc1 = match lvop with None -> BigIntSet.empty | Some lv -> hc_lv lv in
    let hc2 =
      List.fold_left (fun acc arg ->
        BigIntSet.union (hc_exp arg) acc
      ) BigIntSet.empty args in
    BigIntSet.union hc1 (BigIntSet.union hc2 collected_hcs)
  | _ -> collected_hcs

let collect_hc_addrs_path : Global.t -> Path.t -> BigIntSet.t -> BigIntSet.t
= fun global path hcs ->
  let func = FuncMap.find (Path.get_fkey path) global.fmap in
  let g = Lang.get_cfg func in
  let bp = Path.get_bp path in
  List.fold_left (fun acc node ->
    collect_hc_addrs_node g node acc
  ) hcs bp

let collect_hc_addrs_paths : Global.t -> PathSet.t -> BigIntSet.t
= fun global paths ->
  PathSet.fold (fun path acc ->
    collect_hc_addrs_path global path acc
  ) paths BigIntSet.empty

let scan_node : Global.t -> cfg -> Path.t -> Node.t -> QMap.t -> QMap.t
= fun global g path node qmap ->
  let queries = CollectQuery.collect global g VTrue path node in
  List.fold_left (fun acc q ->
    QMap.add (QMap.mk_key q) (UnProven, [], None, VFalse, "", "", "", 0.0, false) acc
  ) qmap queries

let scan_path : Global.t -> Path.t -> QMap.t -> QMap.t
= fun global path qmap ->
  let (fk,nodes) = (Path.get_fkey path, Path.get_bp path) in
  let func = FuncMap.find fk global.fmap in
  let cfg = get_cfg func in
  List.fold_left (fun acc n ->
    scan_node global cfg path n acc
  ) qmap nodes

let init_qmap : Global.t -> PathSet.t -> QMap.t
= fun global paths ->
  PathSet.fold (fun path acc ->
    scan_path global path acc
  ) paths QMap.empty

let main : Global.t -> TypeRank.t -> string BatSet.t ->
           NGramMap.t -> NGramMap.t -> NGramMap.t -> NGramMap.t ->
           PathSet.t -> QMap.t
= fun global rank dict uni_count bi_count tri_count quad_count paths ->
  let (cnstr_paths, rest_paths) = PathSet.partition (fun p -> is_constructor (FuncMap.find (Path.get_fkey p) global.fmap)) paths in
  let rest_paths =
    PathSet.filter (fun p ->
      let f = FuncMap.find (Path.get_fkey p) global.fmap in
      is_public_func f || is_external_func f
    ) rest_paths in
  let qmap = init_qmap global (PathSet.union cnstr_paths rest_paths) in
  let init_txs =
    List.map (fun path ->
      let tseq = [(cnstr_tid, path)] in
      (compute_score global rank dict uni_count bi_count tri_count quad_count tseq,
      (* (compute_score2 global dict uni_count bi_count tri_count quad_count tseq, *)
       exist_inter_contract_call global tseq,
       tseq)
    ) (PathSet.to_list cnstr_paths) in
  let init_workset = List.fold_left Workset.add Workset.empty init_txs in
  let explored = BatSet.empty in
  let hc_addrs = collect_hc_addrs_paths global paths in
  work global hc_addrs rank dict uni_count bi_count tri_count quad_count rest_paths explored init_workset qmap


let validate : QMap.t -> QMap.t
= fun qmap ->
  let i = ref 0 in
  QMap.map (fun (kind,loc,_) ((stat,tseq,mop,vc,s1,s2,s3,time,_) as v) ->
    i := !i+1;
    if stat = Disproven && (kind = IO || kind = ERC20 || kind = ASSERT) then
      let (success,fbase) = BatString.replace (Filename.basename !inputfile) ".sol" "" in
      let _ = assert success in
      let json = "./validation-files/" ^ fbase ^ "_" ^ Vocab.zfill 2 (string_of_int !i) ^ ".json" in
      let cmd = "python3 ~/ValiSmarTest/scripts/run.py single " ^ json in
      let ret = Sys.command cmd in
      if ret = 102 then (stat,tseq,mop,vc,s1,s2,s3,time,true)
      else (stat,tseq,mop,vc,s1,s2,s3,time,false)
    else v
  ) qmap

let load_rank : string -> TypeRank.t
= fun file ->
  let lst = BatList.of_enum (BatFile.lines_of file) in
  let lst =
    List.fold_left (fun acc str ->
      let (typ,cnt) = BatString.split str ~by:"," in
      (typ, int_of_string cnt)::acc
    ) [] lst in
  let lst = List.sort (fun (_,cnt1) (_,cnt2) -> Stdlib.compare cnt1 cnt2) lst in
  let lst = List.rev lst in
  BatList.fold_lefti (fun acc i (t,_) -> TypeRank.add t (i+1) acc) TypeRank.empty lst

let load_model : string -> string BatSet.t * NGramMap.t
= fun file ->
  let lst = BatList.of_enum (BatFile.lines_of file) in
  List.fold_left (fun (acc1,acc2) str ->
    let ngram, cnt = BatString.split str ~by:"," in
    let words = BatString.split_on_char '-' ngram in
    (BatSet.union (BatSet.of_list words) acc1, NGramMap.add ngram (int_of_string cnt) acc2)
  ) (BatSet.empty, NGramMap.empty) lst

let run : Global.t -> PathSet.t -> string list -> QMap.t
= fun global paths lines ->
  Profiler.print_log "Model Uploading ...";
  let rank = if !Options.ngram >0 then load_rank "./src/exploit/train/typeRank.txt" else TypeRank.empty in
  let dict1, uni_count = if !Options.ngram > 0 then load_model "./src/exploit/train/uni_count.txt" else (BatSet.empty, NGramMap.empty) in
  let dict2, bi_count = if !Options.ngram > 0 then load_model "./src/exploit/train/bi_count.txt" else (BatSet.empty, NGramMap.empty) in
  let dict3, tri_count = if !Options.ngram > 0 then load_model "./src/exploit/train/tri_count.txt" else (BatSet.empty, NGramMap.empty) in
  let dict4, quad_count = if !Options.ngram > 0 then load_model "./src/exploit/train/quad_count.txt" else (BatSet.empty, NGramMap.empty) in
  let _ = assert (BatSet.equal dict1 dict2 && BatSet.equal dict2 dict3 && BatSet.equal dict3 dict4 && BatSet.equal dict4 dict1) in
  Profiler.print_log "Generating Exploits ...";
  let qmap = main global rank dict1 uni_count bi_count tri_count quad_count paths in
  let qmap = if !Options.validate then (Profiler.print_log "\nConcrete Validation Begins ..."; validate qmap) else qmap in
  qmap
