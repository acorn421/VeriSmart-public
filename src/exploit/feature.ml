open Lang
open Vocab
open Query

let dimension = 15

(****************************************)
(*** Features for path representation ***)
(****************************************)

type feature = {
  def_top1  : bool;
  def_top2  : bool;
  def_top3  : bool;
  def_top4  : bool;
  def_top5  : bool;
  def_top6  : bool;
 
  use_top1  : bool;
  use_top2  : bool;
  use_top3  : bool;
  use_top4  : bool;
  use_top5  : bool;
  use_top6  : bool;

  payable   : bool;
  send_eth  : bool;
  destruct  : bool;
}

let empty_feature = {
  def_top1  = false;
  def_top2  = false;
  def_top3  = false;
  def_top4  = false;
  def_top5  = false;
  def_top6  = false;

  use_top1  = false;
  use_top2  = false;
  use_top3  = false;
  use_top4  = false;
  use_top5  = false;
  use_top6  = false;

  payable   = false;
  send_eth  = false;
  destruct  = false;
}

let string_of_feature feat =
  let b2i b = if b then "1" else "0" in
   "[" ^
   b2i feat.def_top1 ^
   b2i feat.def_top2 ^
   b2i feat.def_top3 ^
   b2i feat.def_top4 ^
   b2i feat.def_top5 ^
   b2i feat.def_top6 ^

   b2i feat.use_top1 ^
   b2i feat.use_top2 ^
   b2i feat.use_top3 ^
   b2i feat.use_top4 ^
   b2i feat.use_top5 ^
   b2i feat.use_top6 ^

   b2i feat.payable ^
   b2i feat.send_eth ^
   b2i feat.destruct ^
   "]"

let vector_of : feature -> int list
= fun feat ->
  let b2i b = if b then 1 else 0 in
  [b2i feat.def_top1;
   b2i feat.def_top2;
   b2i feat.def_top3;
   b2i feat.def_top4;
   b2i feat.def_top5;
   b2i feat.def_top6;

   b2i feat.use_top1;
   b2i feat.use_top2;
   b2i feat.use_top3;
   b2i feat.use_top4;
   b2i feat.use_top5;
   b2i feat.use_top6;

   b2i feat.payable;
   b2i feat.send_eth;
   b2i feat.destruct
   ]

module TypeRank = struct
  type t = (string, int) BatMap.t

  let empty = BatMap.empty
  let add = BatMap.add
  let mem = BatMap.mem
  let find x m =
    try BatMap.find x m with Not_found -> 0
end

let rec def_of : lv -> var BatSet.t
= fun lv ->
  match lv with
  | Var (v,vinfo) -> BatSet.singleton (v, vinfo.vtype)
  | MemberAccess (e,x,xinfo,_) -> BatSet.singleton (x, xinfo.vtype)
  | IndexAccess (Lv lv,_,_) -> def_of lv
  | IndexAccess (Cast (_, Lv lv),_,_) -> def_of lv
  | Tuple (eops,_) ->
    List.fold_left (fun acc eop ->
      match eop with
      | Some (Lv lv) -> BatSet.union (def_of lv) acc
      | None -> acc
      | _ -> failwith "def_of"
    ) BatSet.empty eops
  | _ -> failwith "def_of"

let is_def_top1 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 1) typs

let is_def_top2 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 2) typs

let is_def_top3 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 3) typs

let is_def_top4 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 4) typs

let is_def_top5 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 5) typs

let is_def_top6 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 6) typs

let is_use_top1 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 1) typs

let is_use_top2 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 2) typs

let is_use_top3 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 3) typs

let is_use_top4 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 4) typs

let is_use_top5 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 5) typs

let is_use_top6 : TypeRank.t -> var BatSet.t -> bool
= fun rank vars ->
  let typs = BatSet.map (fun v -> to_string_typ (get_type_var v)) vars in
  BatSet.exists (fun t -> TypeRank.find t rank = 6) typs

let add_def_top1 : feature -> feature
= fun feat -> {feat with def_top1 = true}

let add_def_top2 : feature -> feature
= fun feat -> {feat with def_top2 = true}

let add_def_top3 : feature -> feature
= fun feat -> {feat with def_top3 = true}

let add_def_top4 : feature -> feature
= fun feat -> {feat with def_top4 = true}

let add_def_top5 : feature -> feature
= fun feat -> {feat with def_top5 = true}

let add_def_top6 : feature -> feature
= fun feat -> {feat with def_top6 = true}

let add_use_top1 : feature -> feature
= fun feat -> {feat with use_top1 = true}

let add_use_top2 : feature -> feature
= fun feat -> {feat with use_top2 = true}

let add_use_top3 : feature -> feature
= fun feat -> {feat with use_top3 = true}

let add_use_top4 : feature -> feature
= fun feat -> {feat with use_top4 = true}

let add_use_top5 : feature -> feature
= fun feat -> {feat with use_top5 = true}

let add_use_top6 : feature -> feature
= fun feat -> {feat with use_top6 = true}

let add_payable : feature -> feature
= fun feat -> {feat with payable = true}

let add_send_eth : feature -> feature
= fun feat -> {feat with send_eth = true}

let add_destruct : feature -> feature
= fun feat -> {feat with destruct = true}

let feature_map : Global.t -> TypeRank.t -> func -> Path.t -> feature
= fun global rank func path ->
  let (fk,nodes) = (Path.get_fkey path, Path.get_bp path) in
  let cfg = Lang.get_cfg (FuncMap.find fk global.fmap) in
  let feat = empty_feature |> (if is_payable func then add_payable else Vocab.id) in
  List.fold_left (fun acc node ->
    let stmt = find_stmt node cfg in
    match stmt with
    | Assign (lv,_,_) ->
      let vars = BatSet.filter (fun x -> List.mem x global.gvars) (def_of lv) in
      acc
      |> (if is_def_top1 rank vars then add_def_top1 else Vocab.id)
      |> (if is_def_top2 rank vars then add_def_top2 else Vocab.id)
      |> (if is_def_top3 rank vars then add_def_top3 else Vocab.id)
      |> (if is_def_top4 rank vars then add_def_top4 else Vocab.id)
      |> (if is_def_top5 rank vars then add_def_top5 else Vocab.id)
      |> (if is_def_top6 rank vars then add_def_top6 else Vocab.id)
    | Assume (e,_) ->
      let vars = BatSet.filter (fun x -> List.mem x global.gvars) (var_exp e) in
      acc
      |> (if is_use_top1 rank vars then add_use_top1 else Vocab.id)
      |> (if is_use_top2 rank vars then add_use_top2 else Vocab.id)
      |> (if is_use_top3 rank vars then add_use_top3 else Vocab.id)
      |> (if is_use_top4 rank vars then add_use_top4 else Vocab.id)
      |> (if is_use_top5 rank vars then add_use_top5 else Vocab.id)
      |> (if is_use_top6 rank vars then add_use_top6 else Vocab.id)
    | Call (lvop,Lv (MemberAccess (e,fname,_,_)),args,_,_,loc,_)
      when is_address (get_type_exp e) && List.mem fname ["transfer";"send"] ->
      let _ = assert (no_eth_gas_modifiers stmt) in
      add_send_eth acc
    | Call (lvop, Lv (MemberAccess (e,"call",_,_)), args, Some eth, gasop, loc, id)
      when is_address (get_type_exp e) ->
      add_send_eth acc
    | Call (lvop,Lv (Var (fname,_)),args,_,_,loc,_)
      when List.mem fname ["selfdestruct";"suicide"] ->
      let _ = assert (List.length args = 1) in
      add_destruct acc
    | _ -> acc
  ) feat nodes

(***************************)
(*** Word representation ***)
(***************************)

type word = S | C | F of feature

let to_string_word : word -> string
= fun word ->
  match word with
  | S -> "<S>"
  | C -> "[C]"
  | F feat -> string_of_feature feat
  (* | OOV -> "[OOV]" *)

let to_string_sentence : word list -> string
= fun words -> string_of_list ~first:"" ~last:"" ~sep:"-" to_string_word words

(* check whether oov or not *)
let is_oov : string BatSet.t -> feature -> bool
= fun dict feat ->
  let feat_str = string_of_feature feat in
  let dict' = BatSet.filter (fun w -> w!="<S>" && w!="<E>" && w!="[C]") dict in
  let b = BatSet.exists (fun w -> (BatString.length w) - 2 = dimension) dict' in
  let _ = assert b in
  let _ = assert (BatString.length feat_str - 2 = dimension) in (* deduct '[' and ']' *)
  if BatSet.mem feat_str dict then false
  else true

let similarity : int list -> int list -> int
= fun vec1 vec2 ->
  let (_,score) =
  List.fold_left2 (fun (i,acc) e1 e2 ->
    if e1*e2 = 1 then
      if i=0 then (i+1, acc+12)
      else if i=1 then (i+1, acc+11)
      else if i=2 then (i+1, acc+10)
      else if i=3 then (i+1, acc+9)
      else if i=4 then (i+1, acc+8)
      else if i=5 then (i+1, acc+7)
      else if i=6 then (i+1, acc+6)
      else if i=7 then (i+1, acc+5)
      else if i=8 then (i+1, acc+4)
      else if i=9 then (i+1, acc+3)
      else if i=10 then (i+1, acc+2)
      else if i=11 then (i+1, acc+1)
      else if i=12 then (i+1, acc+13) (* payable *)
      else if i=13 then (i+1, acc+13) (* send eth *)
      else if i=14 then (i+1, acc+13) (* destruct *)
      else failwith "similarity"
    else (assert (e1*e2 = 0); (i+1, acc))
  ) (0,0) vec1 vec2 in
  score

let find_optimal : feature -> string BatSet.t -> feature
= fun target dict ->
  let target = vector_of target in
  let dict = BatSet.filter (fun e -> not (e = "<E>") && not (e="<S>") && not (e="[C]")) dict in
  (* let _ = print_endline (string_of_set Vocab.id dict) in *)
  let dict =
    BatSet.map (fun str ->
      BatString.fold_left (fun acc c ->
        if c = '[' || c =']' then acc else
        if c='1' then acc @ [1] else
        if c='0' then acc @ [0]
        else assert false
      ) [] str
    ) dict in
  let dict = BatSet.to_list dict in
  (* let _ = List.iter (fun l -> print_endline (string_of_list string_of_int l)) dict in
  let _ = assert false in *)
  let (score,cand) =
    List.fold_left (fun (acc_max,acc_cand) cand ->
      let score = similarity target cand in
      if score > acc_max then (score, cand)
      else (acc_max, acc_cand)
    ) (-1, List.hd dict) dict
  in
  let feat =
    BatList.fold_lefti (fun acc i e ->
      if i=0 && e=1 then add_def_top1 acc
      else if i=1 && e=1 then add_def_top2 acc
      else if i=2 && e=1 then add_def_top3 acc
      else if i=3 && e=1 then add_def_top4 acc
      else if i=4 && e=1 then add_def_top5 acc
      else if i=5 && e=1 then add_def_top6 acc

      else if i=6 && e=1 then add_use_top1 acc
      else if i=7 && e=1 then add_use_top2 acc
      else if i=8 && e=1 then add_use_top3 acc
      else if i=9 && e=1 then add_use_top4 acc
      else if i=10 && e=1 then add_use_top5 acc
      else if i=11 && e=1 then add_use_top6 acc

      else if i=12 && e=1 then add_payable acc
      else if i=13 && e=1 then add_send_eth acc
      else if i=14 && e=1 then add_destruct acc
      else acc
    ) empty_feature cand in
  feat

let word_map: Global.t -> TypeRank.t -> string BatSet.t -> Path.t -> word
= fun global rank dict path ->
  let func = FuncMap.find (Path.get_fkey path) global.fmap in
  if is_constructor func then C
  else
    let feat = feature_map global rank func path in
    if is_oov dict feat then
      let feat' = find_optimal feat dict in
      (* let _ = print_endline (get_fname func ^ " : " ^ string_of_feature feat ^ " -> " ^ string_of_feature feat') in *)
      F feat'
    else
      (* let _ = print_endline (get_fname func ^ " : " ^ string_of_feature feat) in *)
      F feat

(*****************************************************)
(*** Transaction representations in training phase ***)
(*****************************************************)

type raw_feat = {
  raw_def : typ BatSet.t;
  raw_use : typ BatSet.t;
  raw_payable : bool;
  raw_send_eth : bool;
  raw_destruct : bool;
}

let empty_raw_feature = {
  raw_def = BatSet.empty;
  raw_use = BatSet.empty;
  raw_payable = false;
  raw_send_eth = false;
  raw_destruct = false;
}

type raw_word = S' | C' | F' of raw_feat

let is_raw_payable : func -> bool
= fun func -> (get_finfo func).is_payable

let add_raw_def : typ BatSet.t -> raw_feat -> raw_feat
= fun typs feat -> {feat with raw_def = BatSet.union typs feat.raw_def}

let add_raw_use : typ BatSet.t -> raw_feat -> raw_feat
= fun typs feat -> {feat with raw_use = BatSet.union typs feat.raw_use}

let add_raw_payable : raw_feat -> raw_feat
= fun raw_feat -> {raw_feat with raw_payable = true}

let add_raw_send_eth : raw_feat -> raw_feat
= fun raw_feat -> {raw_feat with raw_send_eth = true}

let add_raw_destruct : raw_feat -> raw_feat
= fun raw_feat -> {raw_feat with raw_destruct = true}

let raw_feature_map : Global.t -> func -> Path.t -> raw_feat
= fun global func path ->
  let (fk,nodes) = (Path.get_fkey path, Path.get_bp path) in
  let cfg = Lang.get_cfg (FuncMap.find fk global.fmap) in
  let raw_feat = empty_raw_feature |> (if is_raw_payable func then add_raw_payable else Vocab.id) in
  List.fold_left (fun acc node ->
    let stmt = find_stmt node cfg in
    match stmt with
    | Assign (lv,_,_) ->
      let vars = BatSet.filter (fun x -> List.mem x global.gvars) (def_of lv) in
      let typs = BatSet.map get_type_var vars in
      add_raw_def typs acc
    | Assume (e,_) ->
      let vars = BatSet.filter (fun x -> List.mem x global.gvars) (var_exp e) in
      let typs = BatSet.map get_type_var vars in
      add_raw_use typs acc
    | Call (lvop,Lv (MemberAccess (e,fname,_,_)),args,_,_,loc,_)
      when is_address (get_type_exp e) && List.mem fname ["transfer";"send"] ->
      let _ = assert (no_eth_gas_modifiers stmt) in
      add_raw_send_eth acc
    | Call (lvop, Lv (MemberAccess (e,"call",_,_)), args, Some eth, gasop, loc, id)
      when is_address (get_type_exp e) ->
      add_raw_send_eth acc
    | Call (lvop,Lv (Var (fname,_)),args,_,_,loc,_)
      when List.mem fname ["selfdestruct";"suicide"] ->
      let _ = assert (List.length args = 1) in
      add_raw_destruct acc
    | _ -> acc
  ) raw_feat nodes

let raw_word_map : Global.t -> Path.t -> raw_word
= fun global path ->
  let func = FuncMap.find (Path.get_fkey path) global.fmap in
  if is_constructor func then C'
  else F' (raw_feature_map global func path)


(********************************)
(*** Abstracting transactions ***)
(********************************)

let mk_word : Global.t -> TypeRank.t -> string BatSet.t -> Transaction.t -> word
= fun global rank dict (tid,path) -> word_map global rank dict path

let mk_word_list : Global.t -> TypeRank.t -> string BatSet.t -> Transaction.t list -> word list
= fun global rank dict tseq -> List.map (mk_word global rank dict) tseq

let transform_raw_word : Global.t -> Transaction.t -> raw_word
= fun global (tid,path) -> raw_word_map global path

let transform_raw_sentence : Global.t -> Transaction.t list -> raw_word list
= fun global tseq -> List.map (transform_raw_word global) tseq


(*******************************************************************)
(*** To-string functions for raw representatinos of transactinos ***)
(*******************************************************************)

(* overwrite the one in lang.ml *)
let rec to_string_typ_w typ =
  match typ with
  | ConstInt -> "int_const"
  | ConstReal -> "rational_const"
  | ConstString -> "literal_string"
  | EType etyp -> to_string_etyp etyp
  | Mapping (etyp,typ) -> "mapping" ^ "(" ^ to_string_etyp etyp ^ "=>" ^ to_string_typ_w typ ^ ")"
  | Mapping2 (t1,t2) -> "mapping2" ^ "(" ^ to_string_typ_w t1 ^ "=>" ^ to_string_typ_w t2 ^ ")"
  | Array (typ,None) -> to_string_typ_w typ ^ "[]"
  | Array (typ,Some n) -> to_string_typ_w typ ^ "[" ^ string_of_int n ^ "]"
  | Void -> "void"
  | Contract id -> "Contract"
  | Struct id -> "Struct"
  | Enum id -> "Enum"
  | TupleType typs -> "Tuple" ^ string_of_list ~first:"(" ~last:")" ~sep:", " to_string_typ_w typs

let to_string_raw_feature feat =
  string_of_set ~first:"" ~last:"" ~sep:"@" to_string_typ_w feat.raw_def ^ ":" ^
  string_of_set ~first:"" ~last:"" ~sep:"@" to_string_typ_w feat.raw_use ^ ":" ^
  (if feat.raw_payable then "1" else "0") ^ ":" ^
  (if feat.raw_send_eth then "1" else "0") ^ ":" ^
  (if feat.raw_destruct then "1" else "0")

let to_string_raw_word : raw_word -> string
= fun raw_word ->
  match raw_word with
  | S' -> "<S>"
  | C' -> "[C]"
  | F' feat -> to_string_raw_feature feat

let to_string_raw_sentence : raw_word list -> string
= fun words -> string_of_list ~first:"" ~last:"" ~sep:"-" to_string_raw_word words
