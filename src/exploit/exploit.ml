open Lang
open Vlang
open Z3Interface
open Vocab
open Options
open Query
open Prob
open Feature
open Path
open Semantics
open ReportExploit
open Transaction
open ExecTran
open ExploitUtils

let rec mk_ngram : int -> 'a list -> 'a list list
= fun n lst ->
  let ngram = BatList.take n lst in
  if List.length lst = n then [ngram]
  else ngram :: (mk_ngram n (List.tl lst))

let cost_ngram : Global.t -> TypeRank.t -> string BatSet.t -> count_maps ->
                 transaction list -> float
= fun global rank dict counts tseq ->
  let rec add_pseudo_words n = if n=0 then [] else (S::add_pseudo_words (n-1)) in
  let word_list = mk_word_list global rank dict tseq in
  let sentence = (add_pseudo_words (!Options.ngram-1)) @ word_list in
  let ngrams = mk_ngram !Options.ngram sentence in
  let log_prob =
    List.fold_left (fun acc ngram ->
      let str = Feature.to_string_sentence ngram in
      let prob =
        if !Options.ngram = 2 then Prob.interpolation_bi dict counts str else
        if !Options.ngram = 3 then Prob.interpolation_tri dict counts str else
        if !Options.ngram = 4 then Prob.interpolation_quad dict counts str
        else failwith "unknown ngram option" in
      acc +. prob
    ) (log 1.) ngrams in
  if BatString.equal !Options.debug "prob" then
    (prerr_endline "\n";
     prerr_endline (to_string_tseq global tseq);
     prerr_endline (to_string_sentence sentence);
     prerr_endline (string_of_float log_prob);
     prerr_endline (string_of_float (exp log_prob)));
  -. log_prob

let compute_cost : Global.t -> TypeRank.t -> string BatSet.t -> count_maps ->
                   transaction list -> float
= fun global rank dict counts tseq ->
  if !Options.ngram > 0 then cost_ngram global rank dict counts tseq
  else float_of_int (List.length tseq)


(* produce next candidates *)
let next : vformula -> Global.t -> PathSet.t -> transaction list -> transaction list list
= fun state global paths tseq ->
  let safety = VFalse in
  let vc = VAnd (state, VNot safety) in
  let vc_sim = ExploitUtils.simplify global tseq vc in
  let (signal,mop) = sat_wrapper vc_sim in
  if signal = 0 then [] (* UNSAT: infeasible path *)
  else
  (* let state = Simplification.fix_normalize state in
  if equal_vf state VFalse then []
  else *)
    PathSet.fold (fun new_p acc ->
      let last_tx = BatList.last tseq in
      let last_tx_fname = get_fname (FuncMap.find (Path.get_fkey (get_path last_tx)) global.fmap) in
      if not (BatString.starts_with last_tx_fname "smartest_")
         && List.length tseq - 1 < !Options.transaction_depth (* substract 1 to exclude constructor when counting length *) then
         let new_t = (fresh_tid (), new_p) in
         (tseq @ [new_t])::acc
      else acc
    ) paths []

let rec work : Global.t -> TypeRank.t -> string BatSet.t -> count_maps ->
               PathSet.t -> int list BatSet.t -> Workset.t -> QMap.t -> QMap.t
= fun global rank dict counts paths explored workset qmap ->
  if QMap.for_all (fun k (stat,_,_,_,_,_,_,_,_) -> stat = Disproven) qmap then qmap
  else if (Sys.time () -. !Profiler.start_cpu) > float_of_int !Options.exploit_timeout then qmap
  else
  let _ = iter := !iter + 1 in
  let _ =
    if !iter mod 1000 = 1 then
      (prerr_string ("Iter : " ^ string_of_int !iter ^ ", ");
       prerr_endline (Workset.workset_info workset ^ ", " ^ "Total elapsed : " ^ (string_of_float (Sys.time () -. !Profiler.start_cpu)))) in
  match Workset.pick_min workset with
  | None -> qmap
  | Some (prob,tseq) ->
    max_explored_depth := max !max_explored_depth (List.length tseq - 1);
    if BatString.equal !Options.debug "wpick" then
      prerr_endline (to_string_tseq global tseq ^ "," ^ "log prob: " ^ string_of_float (-. prob) ^ "," ^ "prob: " ^ string_of_float (exp (-. prob)));
    let workset = Workset.remove_min workset in
    let (state,queries) = exec_transactions global tseq in
    let qmap = inspect_queries global tseq queries qmap in
    let nexts = next state global paths tseq in
    let nexts = List.filter (fun tseq -> not (tseq_contain_extern_log global (BatList.take (BatList.length tseq - 1) tseq))) nexts in
    let dup_exist = List.exists (fun next_tseq -> (BatSet.mem (List.map fst next_tseq) explored)) nexts in
    let _ = assert (not dup_exist) in (* invariant: duplicated sequences are not enumerated *)
    let explored = List.fold_left (fun acc next_tseq -> BatSet.add (List.map fst next_tseq) acc) explored nexts in
    let nexts = List.map (fun next -> (compute_cost global rank dict counts next, next)) nexts in
    let workset = List.fold_left Workset.add workset nexts in
    work global rank dict counts paths explored workset qmap

let scan_node : Global.t -> cfg -> Path.t -> Node.t -> query list
= fun global g path node -> CollectQuery.collect global g VTrue path node

let scan_path : Global.t -> Path.t -> query list
= fun global path ->
  let (fk,nodes) = (Path.get_fkey path, Path.get_bp path) in
  let func = FuncMap.find fk global.fmap in
  let cfg = get_cfg func in
  List.fold_left (fun acc n -> (scan_node global cfg path n) @ acc) [] nodes

let scan_paths : Global.t -> PathSet.t -> query list
= fun global paths ->
  PathSet.fold (fun path acc -> (scan_path global path) @ acc) paths []

let init_qmap : query list -> QMap.t
= fun queries ->
  List.fold_left (fun acc q ->
    QMap.add (QMap.mk_key q) (UnProven, [], None, VFalse, "", "", "", 0.0, false) acc
  ) QMap.empty queries


let main : Global.t -> TypeRank.t -> string BatSet.t -> count_maps ->
           PathSet.t -> QMap.t
= fun global rank dict counts paths ->
  let (cnstr_paths, rest_paths) = PathSet.partition (fun p -> is_constructor (FuncMap.find (Path.get_fkey p) global.fmap)) paths in
  let rest_paths =
    PathSet.filter (fun p ->
      let f = FuncMap.find (Path.get_fkey p) global.fmap in
      is_public_func f || is_external_func f
    ) rest_paths in
  let queries = scan_paths global (PathSet.union cnstr_paths rest_paths) in
  let qmap = init_qmap queries in
  let init_txs =
    List.map (fun path ->
      let tseq = [(cnstr_tid, path)] in
      (compute_cost global rank dict counts tseq, tseq)
    ) (PathSet.to_list cnstr_paths)
  in
  let init_workset = List.fold_left Workset.add Workset.empty init_txs in
  let explored = BatSet.empty in
  work global rank dict counts rest_paths explored init_workset qmap

let validate : QMap.t -> QMap.t
= fun qmap ->
  let i = ref 0 in
  QMap.map (fun (kind,loc,_) ((stat,tseq,mop,vc,s1,s2,s3,time,_) as v) ->
    i := !i+1;
    if stat = Disproven && (kind = IO || kind = ERC20 || kind = ASSERT) then
      let (success,fbase) = BatString.replace (Filename.basename !inputfile) ".sol" "" in
      let _ = assert success in
      let json = "./validation-files/" ^ fbase ^ "_" ^ Vocab.zfill 2 (string_of_int !i) ^ ".json" in
      let cmd = "python3 ~/ValiSmarTest/scripts/run.py single " ^ json in
      let ret = Sys.command cmd in
      if ret = 102 then (stat,tseq,mop,vc,s1,s2,s3,time,true)
      else (stat,tseq,mop,vc,s1,s2,s3,time,false)
    else v
  ) qmap

let load_rank : string -> TypeRank.t
= fun file ->
  let lst = BatList.of_enum (BatFile.lines_of file) in
  let lst =
    List.fold_left (fun acc str ->
      let (typ,cnt) = BatString.split str ~by:"," in
      (typ, int_of_string cnt)::acc
    ) [] lst in
  let lst = List.sort (fun (_,cnt1) (_,cnt2) -> Stdlib.compare cnt1 cnt2) lst in
  let lst = List.rev lst in
  BatList.fold_lefti (fun acc i (t,_) -> TypeRank.add t (i+1) acc) TypeRank.empty lst

let load_model : string -> string BatSet.t * NGramMap.t
= fun file ->
  let lst = BatList.of_enum (BatFile.lines_of file) in
  List.fold_left (fun (acc1,acc2) str ->
    let ngram, cnt = BatString.split str ~by:"," in
    let words = BatString.split_on_char '-' ngram in
    (BatSet.union (BatSet.of_list words) acc1, NGramMap.add ngram (int_of_string cnt) acc2)
  ) (BatSet.empty, NGramMap.empty) lst

let load_model_all () =
  let b = !Options.ngram > 0 in
  let dict1, uni_count = if b then load_model "./src/exploit/train/uni_count.txt" else (BatSet.empty, NGramMap.empty) in
  let dict2, bi_count = if b then load_model "./src/exploit/train/bi_count.txt" else (BatSet.empty, NGramMap.empty) in
  let dict3, tri_count = if b then load_model "./src/exploit/train/tri_count.txt" else (BatSet.empty, NGramMap.empty) in
  let dict4, quad_count = if b then load_model "./src/exploit/train/quad_count.txt" else (BatSet.empty, NGramMap.empty) in
  let _ = assert (BatSet.equal dict1 dict2 && BatSet.equal dict2 dict3 && BatSet.equal dict3 dict4 && BatSet.equal dict4 dict1) in
  (dict1, {uni=uni_count; bi=bi_count; tri=tri_count; quad=quad_count})

let load_rank_dict_counts () =
  if !Options.ngram <= 0 then
    let _ = print_endline ("[INFO] Model not uploaded - running basic symbolic execution") in
    let counts = {uni=NGramMap.empty; bi=NGramMap.empty; tri=NGramMap.empty; quad=NGramMap.empty} in
    (TypeRank.empty, BatSet.empty, counts)
  else
    let _ = Profiler.start "[INFO] Model uploading ... " in
    let rank = load_rank "./src/exploit/train/typeRank.txt" in
    let dict1, uni_count = load_model "./src/exploit/train/uni_count.txt" in
    let dict2, bi_count = load_model "./src/exploit/train/bi_count.txt" in
    let dict3, tri_count = load_model "./src/exploit/train/tri_count.txt" in
    let dict4, quad_count = load_model "./src/exploit/train/quad_count.txt" in
    let _ = assert (BatSet.equal dict1 dict2 && BatSet.equal dict2 dict3 && BatSet.equal dict3 dict4 && BatSet.equal dict4 dict1) in
    let counts = {uni=uni_count; bi=bi_count; tri=tri_count; quad=quad_count} in
    let _ = Profiler.finish "[INFO] Model uploading ... " in
    (rank, dict1, counts)

let set_contract_init_eth () =
  if BatBig_int.equal !Options.contract_init_eth BatBig_int.zero
     && !Options.check_leak && not !Options.enforce_init_eth then
       let _ = print_endline ("[INFO] Give 10 Ethers to the contract : Ether-leaking checker is activated") in
       contract_init_eth := BatBig_int.mul (BatBig_int.of_int 10) (BatBig_int.pow (BatBig_int.of_int 10) (BatBig_int.of_int 18))
  else ()

let run : Global.t -> PathSet.t -> QMap.t
= fun global paths ->
  let _ = set_contract_init_eth () in
  let (rank, dict, counts) = load_rank_dict_counts () in
  Profiler.print_log "[INFO] Generating Exploits ...\n";
  let qmap = main global rank dict counts paths in
  let qmap = if !Options.validate then (Profiler.print_log "\nConcrete Validation Begins ..."; validate qmap) else qmap in
  qmap
