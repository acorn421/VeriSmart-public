open Lang
open Query
open Vocab

exception Deviation

let transfer_deviated = ref false
let transferFrom_deviated = ref false
let approve_deviated = ref false
let balance_deviated = ref false
let allowance_deviated = ref false
let total_deviated = ref false

type interface = string * typ list * typ list 

let get_interface : func -> interface 
= fun f -> (get_fname f, get_param_types f, get_ret_param_types f)

let equal_interface : interface -> interface -> bool
= fun (x,t1,t2) (x',t1',t2') -> BatString.equal x x' && t1=t1' && t2=t2'

let transfer_interface = ("transfer", [EType Address; EType (UInt 256)], [EType Bool])
let transferFrom_interface = ("transferFrom", [EType Address; EType Address; EType (UInt 256)], [EType Bool])
let approve_interface = ("approve", [EType Address; EType (UInt 256)], [EType Bool])

let balance_name = ref ""
let allow_name = ref ""
let total_name = ref ""

let transfer : (id * vinfo) list -> contract -> func
= fun gvars c ->
  let transfers = List.find_all (fun f -> f |> get_interface |> equal_interface transfer_interface) (get_funcs c) in
  let bals = List.find_all (fun g -> is_usual_mapping (snd g).vtype && BatString.starts_with (fst g) "balance") gvars in
  if List.length transfers = 0 || List.length transfers >= 2 then (transfer_deviated:=true; raise Deviation)
  else if List.length bals = 0 || List.length bals >= 2 then (balance_deviated:=true; raise Deviation)
  else
    let bal = List.hd bals in
    let _ = balance_name := fst (BatString.split (fst bal) "__") in
    let fname = "smartest_transfer" in
    let msg = ("msg.sender", dummy_vinfo_with_typ_org (EType Address) "msg.sender") in
    let _to = ("@to", dummy_vinfo_with_typ_org (EType Address) "@to") in
    let value = ("@value", dummy_vinfo_with_typ_org (EType (UInt 256)) "@value") in
    let params = [_to; value] in
    let pre_msg = ("@pre_msg", dummy_vinfo_with_typ_org (EType (UInt 256)) "@pre_msg") in
    let pre_to = ("@pre_to", dummy_vinfo_with_typ_org (EType (UInt 256)) "@pre_to") in
    let ret = ("@ret", dummy_vinfo_with_typ_org (EType Bool) "@ret") in
    let assume = Assume (mk_neq (Lv (Var msg)) (Lv (Var _to)), -1) in
    let assign_msg = Assign (Var pre_msg, mk_index_access (Lv (Var bal)) (Lv (Var msg)), -1) in
    let assign_to = Assign (Var pre_to, mk_index_access (Lv (Var bal)) (Lv (Var _to)), -1) in
    let call = Call (Some (Var ret), Lv (Var ("transfer", dummy_vinfo)), [Lv (Var _to); Lv (Var value)], None, None, -1, -1) in

    let success = mk_and (mk_eq (Lv (Var ret)) True) (mk_ge (Lv (Var pre_msg)) (Lv (Var value))) in
    let failure = mk_eq (Lv (Var ret)) False in
    let check_enough = Assert (mk_or success failure, "erc20", code_transfer_sender_has_enough_money) in

    let success = mk_and (mk_eq (Lv (Var ret)) True) (mk_eq (mk_index_access (Lv (Var bal)) (Lv (Var msg))) (BinOp (Sub, Lv (Var pre_msg), Lv (Var value), mk_einfo (EType (UInt 256))))) in
    let failure = mk_and (mk_eq (Lv (Var ret)) False) (mk_eq (mk_index_access (Lv (Var bal)) (Lv (Var msg))) (Lv (Var pre_msg))) in 
    let check_msg = Assert (mk_or success failure, "erc20", code_transfer_sender_bal_dec) in

    let success = mk_and (mk_eq (Lv (Var ret)) True) (mk_eq (mk_index_access (Lv (Var bal)) (Lv (Var _to))) (BinOp (Add, Lv (Var pre_to), Lv (Var value), mk_einfo (EType (UInt 256))))) in
    let failure = mk_and (mk_eq (Lv (Var ret)) False) (mk_eq (mk_index_access (Lv (Var bal)) (Lv (Var _to))) (Lv (Var pre_to))) in 
    let check_to = Assert (mk_or success failure, "erc20", code_transfer_recipient_bal_inc) in

    let stmt = Seq (assume, Seq (assign_msg, Seq (assign_to, Seq (call, Seq (check_enough, Seq (check_msg, check_to)))))) in 
    let finfo = mk_finfo c in
    (fname, params, [], stmt, finfo)

let transferFrom : (id * vinfo) list -> contract -> func
= fun gvars c ->
  let transferFroms = List.find_all (fun f -> f |> get_interface |> equal_interface transferFrom_interface) (get_funcs c) in
  let bals = List.find_all (fun g -> is_usual_mapping (snd g).vtype && BatString.starts_with (fst g) "balance") gvars in
  let allows = List.find_all (fun g -> is_usual_allowance (snd g).vtype && BatString.starts_with (fst g) "allow") gvars in
  if List.length transferFroms = 0 || List.length transferFroms >= 2 then (transferFrom_deviated:=true; raise Deviation)
  else if List.length bals = 0 || List.length bals >= 2 then (balance_deviated:=true; raise Deviation)
  else if List.length allows = 0 || List.length allows >= 2 then (allowance_deviated:=true; raise Deviation)
  else
    let bal = List.hd bals in
    let allow = List.hd allows in
    let _ = balance_name := fst (BatString.split (fst bal) "__") in
    let _ = allow_name := fst (BatString.split (fst allow) "__") in
    let fname = "smartest_transferFrom" in
    let msg = ("msg.sender", dummy_vinfo_with_typ_org (EType Address) "msg.sender") in
    let _from = ("@from", dummy_vinfo_with_typ_org (EType Address) "@from") in
    let _to = ("@to", dummy_vinfo_with_typ_org (EType Address) "@to") in
    let value = ("@value", dummy_vinfo_with_typ_org (EType (UInt 256)) "@value") in
    let params = [_from; _to; value] in 
    let pre_from = ("@pre_from", dummy_vinfo_with_typ_org (EType (UInt 256)) "@pre_from") in
    let pre_to = ("@pre_to", dummy_vinfo_with_typ_org (EType (UInt 256)) "@pre_to") in
    let pre_msg = ("@pre_msg", dummy_vinfo_with_typ_org (EType (UInt 256)) "@pre_msg") in
    let ret = ("@ret", dummy_vinfo_with_typ_org (EType Bool) "@ret") in

    let assume = Assume (BinOp (NEq, Lv (Var _from), Lv (Var _to), mk_einfo (EType Bool)), -1) in
    let assign_from = Assign (Var pre_from, mk_index_access (Lv (Var bal)) (Lv (Var _from)), -1) in
    let assign_to = Assign (Var pre_to, mk_index_access (Lv (Var bal)) (Lv (Var _to)), -1) in
    let assign_msg = Assign (Var pre_msg, mk_index_access (mk_index_access (Lv (Var allow)) (Lv (Var _from))) (Lv (Var msg)), -1) in
    let call = Call (Some (Var ret), Lv (Var ("transferFrom", dummy_vinfo)), [Lv (Var _from); Lv (Var _to); Lv (Var value)], None, None, -1, -1) in

    let success = mk_and (mk_eq (Lv (Var ret)) True) (mk_ge (Lv (Var pre_from)) (Lv (Var value))) in
    let failure = mk_eq (Lv (Var ret)) False in 
    let check1 = Assert (mk_or success failure, "erc20", code_transferFrom_from_bal_enough) in

    let success = mk_and (mk_eq (Lv (Var ret)) True) (mk_ge (Lv (Var pre_msg)) (Lv (Var value))) in
    let failure = mk_eq (Lv (Var ret)) False in
    let check2 = Assert (mk_or success failure, "erc20", code_transferFrom_sender_allow_enough) in

    let success = mk_and (mk_eq (Lv (Var ret)) True) (mk_eq (mk_index_access (Lv (Var bal)) (Lv (Var _from))) (BinOp (Sub, Lv (Var pre_from), Lv (Var value), mk_einfo (EType (UInt 256))))) in
    let failure = mk_and (mk_eq (Lv (Var ret)) False) (mk_eq (mk_index_access (Lv (Var bal)) (Lv (Var _from))) (Lv (Var pre_from))) in
    let check3 = Assert (mk_or success failure, "erc20", code_transferFrom_from_bal_dec) in

    let success = mk_and (mk_eq (Lv (Var ret)) True) (mk_eq (mk_index_access (Lv (Var bal)) (Lv (Var _to))) (BinOp (Add, Lv (Var pre_to), Lv (Var value), mk_einfo (EType (UInt 256))))) in
    let failure = mk_and (mk_eq (Lv (Var ret)) False) (mk_eq (mk_index_access (Lv (Var bal)) (Lv (Var _to))) (Lv (Var pre_to))) in
    let check4 = Assert (mk_or success failure, "erc20", code_transferFrom_to_bal_inc) in

    let new_allowance =  mk_index_access (mk_index_access (Lv (Var allow)) (Lv (Var _from))) (Lv (Var msg)) in
    let success = mk_and (mk_eq (Lv (Var ret)) True) (mk_eq new_allowance (BinOp (Sub, Lv (Var pre_msg), Lv (Var value), mk_einfo (EType (UInt 256))))) in
    let failure = mk_and (mk_eq (Lv (Var ret)) False) (mk_eq new_allowance (Lv (Var pre_msg))) in 
    let check5 = Assert (mk_or success failure, "erc20", code_transferFrom_sender_allow_dec) in

    let stmt = Seq (assume, Seq (assign_from, Seq (assign_to, Seq (assign_msg, Seq (call, Seq (check1, Seq (check2, Seq (check3, Seq (check4, check5))))))))) in
    let finfo = mk_finfo c in
    (fname, params, [], stmt, finfo)

let approve : (id * vinfo) list -> contract -> func
= fun gvars c ->
  let approves = List.find_all (fun f -> f |> get_interface |> equal_interface approve_interface) (get_funcs c) in
  let allows = List.find_all (fun g -> is_usual_allowance (snd g).vtype && BatString.starts_with (fst g) "allow") gvars in
  if List.length approves = 0 || List.length approves >= 2 then (approve_deviated:=true; raise Deviation)
  else if List.length allows = 0 || List.length allows >= 2 then (allowance_deviated:=true; raise Deviation)
  else
    let allow = List.hd allows in
    let _ = allow_name := fst (BatString.split (fst allow) "__") in
    let fname = "smartest_approve" in
    let msg = ("msg.sender", dummy_vinfo_with_typ_org (EType Address) "msg.sender") in
    let spender = ("@spender", dummy_vinfo_with_typ_org (EType Address) "@spender") in
    let value = ("@value", dummy_vinfo_with_typ_org (EType (UInt 256)) "@value") in
    let pre = ("@pre", dummy_vinfo_with_typ_org (EType (UInt 256)) "@pre") in
    let ret = ("@ret", dummy_vinfo_with_typ_org (EType Bool) "@ret") in

    let params = [spender; value] in
    let assign = Assign (Var pre, mk_index_access (mk_index_access (Lv (Var allow)) (Lv (Var msg))) (Lv (Var spender)), -1) in
    let call = Call (Some (Var ret), Lv (Var ("approve", dummy_vinfo)), [Lv (Var spender); Lv (Var value)], None, None, -1, -1) in
    
    let allowance = mk_index_access (mk_index_access (Lv (Var allow)) (Lv (Var msg))) (Lv (Var spender)) in 
    let success = mk_and (mk_eq (Lv (Var ret)) True) (mk_eq allowance (Lv (Var value))) in
    let failure = mk_and (mk_eq (Lv (Var ret)) False) (mk_and (mk_eq (Lv (Var value)) (Lv (Var pre))) (mk_eq allowance (Lv (Var pre)))) in 
    let check = Assert (mk_or success failure, "erc20", code_approve_set) in
    let stmt = Seq (assign, Seq (call,check)) in
    let finfo = mk_finfo c in
    (fname, params, [], stmt, finfo) 

let balance_sum_no_overflow : (id * vinfo) list -> contract -> func
= fun gvars c ->
  let bals = List.find_all (fun g -> is_usual_mapping (snd g).vtype && BatString.starts_with (fst g) "balance") gvars in
  if List.length bals = 0 || List.length bals >= 2 then (balance_deviated:=true; raise Deviation)
  else
    let bal = List.hd bals in
    let _ = balance_name := fst (BatString.split (fst bal) "__") in
    let fname = "smartest_sum_should_not_overflow" in
    let addr1 = ("@addr1", dummy_vinfo_with_typ_org (EType Address) "@addr1") in
    let addr2 = ("@addr2", dummy_vinfo_with_typ_org (EType Address) "@addr2") in
    let params = [addr1; addr2] in
    let plus = BinOp (Add, mk_index_access (Lv (Var bal)) (Lv (Var addr1)), mk_index_access (Lv (Var bal)) (Lv (Var addr2)), mk_einfo (EType (UInt 256))) in 
    let exp = BinOp (GEq, plus, mk_index_access (Lv (Var bal)) (Lv (Var addr1)), mk_einfo (EType (UInt 256))) in
    let assume1 = Assume (mk_neq (Lv (Var addr1)) (Cast (EType Address, Int BatBig_int.zero)), -1) in
    let assume2 = Assume (mk_neq (Lv (Var addr2)) (Cast (EType Address, Int BatBig_int.zero)), -1) in
    let assume3 = Assume (mk_neq (Lv (Var addr1)) (Lv (Var addr2)), -1) in
    let stmt = Seq (assume1, Seq (assume2, Seq (assume3, Assert (exp, "erc20", code_balance_sum_no_overflow)))) in
    let finfo = mk_finfo c in
    (fname, params, [], stmt, finfo) 

let total_ge_balance : (id * vinfo) list -> contract -> func
= fun gvars c ->
  let bals = List.find_all (fun g -> is_usual_mapping (snd g).vtype && BatString.starts_with (fst g) "balance") gvars in
  let totals = List.find_all (fun g -> is_uint256 (snd g).vtype && BatString.starts_with (fst g) "totalSupply") gvars in
  if List.length bals = 0 || List.length bals >= 2 then (balance_deviated:=true; raise Deviation)
  else if List.length totals = 0 || List.length totals >= 2 then (total_deviated:=true; raise Deviation)
  else
    let bal = List.hd bals in
    let total = List.hd totals in
    let _ = balance_name := fst (BatString.split (fst bal) "__") in
    let _ = total_name := fst (BatString.split (fst total) "__") in
    let fname = "smartest_balance_le_total" in
    let addr = ("@addr", dummy_vinfo_with_typ_org (EType Address) "@addr") in
    let params = [addr] in
    let assume = Assume (mk_neq (Lv (Var addr)) (Cast (EType Address, Int BatBig_int.zero)), -1) in
    let exp = BinOp (GEq, Lv (Var total), mk_index_access (Lv (Var bal)) (Lv (Var addr)), mk_einfo (EType Bool)) in
    let stmt = Seq (assume, Assert (exp, "erc20", code_total_ge_balance)) in
    let finfo = mk_finfo c in
    (fname, params, [], stmt, finfo)

let insert_c : (id * vinfo) list -> contract-> contract
= fun gvars c ->
  let funcs = get_funcs c in
  let append a b = (@) b a in
  let funcs' =
    funcs
    |> (try append [transfer gvars c] with Deviation -> id)
    |> (try append [transferFrom gvars c] with Deviation -> id)
    (* |> (try append [approve gvars c] with Deviation -> id) *)
    |> (try append [balance_sum_no_overflow gvars c] with Deviation -> id)
    |> (try append [total_ge_balance gvars c] with Deviation -> id)
  in
  update_funcs funcs' c

let insert_p : pgm -> pgm
= fun p ->
  let main = get_main_contract p in
  let gvars = List.map (fun (x,_,xinfo) -> (x,xinfo)) (get_decls main) in 
  modify_contract (insert_c gvars main) p

let run pgm = insert_p pgm
