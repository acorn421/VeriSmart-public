open Lang
open Vocab

module NGramMap = struct
  type t = (string, int) BatMap.t

  let find x m = try BatMap.find x m with Not_found -> 0
  let add = BatMap.add
  let empty = BatMap.empty

  let to_string : t -> string
  = fun m ->
    "{" ^ "\n" ^
    BatMap.foldi (fun x y acc ->
      acc ^ x ^ " -> " ^ string_of_int y ^ "\n"
    ) m ""
    ^ "}"
end

type count_maps = {
  uni  : NGramMap.t;
  bi   : NGramMap.t;
  tri  : NGramMap.t;
  quad : NGramMap.t
}

let mle_add_k : string BatSet.t -> NGramMap.t -> NGramMap.t -> string -> string -> float
= fun dict ctx_count ngram_count ctx ngram ->
  let k = 0.2 in
  let c_ngram = float_of_int (NGramMap.find ngram ngram_count) +. k in
  let c_ctx = float_of_int (NGramMap.find ctx ctx_count) +. (k *. float_of_int (BatSet.cardinal dict)) in
  let prob = c_ngram /. c_ctx in
  let _ = assert (prob > 0.0 && prob < 1.0) in
  prob

let interpolation_bi : string BatSet.t -> count_maps -> string -> float
=  fun dict counts ngram ->
   let l1 = 0.9 in
   let l2 = 0.1 in

   let lst = BatString.split_on_char '-' ngram in
   let _ = assert (List.length lst = 2) in

   let bi, bi_ctx = ngram, BatList.at lst 0 in
   let uni = BatList.at lst 1 in

   let c_uni = NGramMap.find uni counts.uni in
   let _ = assert (c_uni > 0) in

   let prob_bi = mle_add_k dict counts.uni counts.bi bi_ctx bi in
   let prob_uni = (float_of_int c_uni) /. (BatMap.fold (fun v acc -> float_of_int v +. acc) counts.uni 0.0) in

   let n1 = l1 *. prob_bi in
   let n2 = l2 *. prob_uni in
   let prob = n1 +. n2 in
   let _ = assert (prob > 0.0 && prob < 1.0) in
   log (prob)

let interpolation_tri : string BatSet.t -> count_maps -> string -> float
= fun dict counts ngram ->
  let l1 = 0.9 in
  let l2 = 0.08 in
  let l3 = 0.02 in

  let lst = BatString.split_on_char '-' ngram in
  let _ = assert (List.length lst = 3) in

  let tri, tri_ctx = ngram, BatList.at lst 0 ^ "-" ^ BatList.at lst 1 in
  let bi, bi_ctx = (BatList.at lst 1 ^ "-" ^ BatList.at lst 2, BatList.at lst 1) in
  let uni = BatList.at lst 2 in

  let c_uni = NGramMap.find uni counts.uni in
  (* let _ = print_endline (NGramMap.to_string uni_count) in
  let _ = print_endline ngram in
  let _ = print_endline uni in *)
  let _ = assert (c_uni > 0) in

  let prob_tri = mle_add_k dict counts.bi counts.tri tri_ctx tri in
  let prob_bi = mle_add_k dict counts.uni counts.bi bi_ctx bi in
  let prob_uni = (float_of_int c_uni) /. (BatMap.fold (fun v acc -> float_of_int v +. acc) counts.uni 0.0) in

  let n1 = l1 *. prob_tri in
  let n2 = l2 *. prob_bi in
  let n3 = l3 *. prob_uni in
  let prob = n1 +. n2 +. n3 in
  
  let _ = assert (prob > 0.0 && prob < 1.0) in
  log (prob)

let interpolation_quad : string BatSet.t -> count_maps -> string -> float
= fun dict counts ngram ->
  let l1 = 0.7 in
  let l2 = 0.2 in
  let l3 = 0.08 in
  let l4 = 0.02 in

  let lst = BatString.split_on_char '-' ngram in
  let _ = assert (List.length lst = 4) in

  let quad, quad_ctx = ngram, BatList.at lst 0 ^ "-" ^ BatList.at lst 1 ^ "-" ^ BatList.at lst 2 in
  let tri, tri_ctx =  (BatList.at lst 1 ^ "-" ^ BatList.at lst 2 ^ "-" ^ BatList.at lst 3,  BatList.at lst 1 ^ "-" ^ BatList.at lst 2) in
  let bi, bi_ctx = (BatList.at lst 2 ^ "-" ^ BatList.at lst 3, BatList.at lst 2) in
  let uni = BatList.at lst 3 in

  (* let c_quad = NGramMap.find quad quad_count in
  let c_tri = NGramMap.find tri tri_count in
  let c_bi = NGramMap.find bi bi_count in *)
  let c_uni = NGramMap.find uni counts.uni in
  let _ = assert (c_uni > 0) in

  let prob_quad = mle_add_k dict  counts.tri counts.quad quad_ctx quad in
  let prob_tri  = mle_add_k dict  counts.bi  counts.tri  tri_ctx  tri  in
  let prob_bi   = mle_add_k dict  counts.uni counts.bi   bi_ctx   bi   in
  let prob_uni  = (float_of_int c_uni) /. (BatMap.fold (fun v acc -> float_of_int v +. acc) counts.uni 0.0) in

  let n1 = l1 *. prob_quad in
  let n2 = l2 *. prob_tri in
  let n3 = l3 *. prob_bi in
  let n4 = l4 *. prob_uni in
  let prob = n1 +. n2 +. n3 +. n4 in

  let _ = assert (prob > 0.0 && prob < 1.0) in
  log (prob)
